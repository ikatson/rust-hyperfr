// == == == == == == == == == == == == == == ==
// Returns a result of a translation table walk
//
// Implementations might cache information from memory in any number of non-coherent TLB
// caching structures, and so avoid memory accesses that have been expressed in this
// pseudocode. The use of such TLBs is not expressed in this pseudocode.

TLBRecord AArch64.TranslationTableWalk(bits(48) ipaddress, bits(64) vaddress,
                                       AccType acctype, boolean iswrite, boolean secondstage,
                                       boolean s2fs1walk, integer size)

    if !secondstage then
        assert !ELUsingAArch32(S1TranslationRegime());
    else
        assert HaveEL(EL2) & & !IsSecure() & & !ELUsingAArch32(EL2) & & PSTATE.EL != EL2;

    TLBRecord result;
    AddressDescriptor descaddr;
    bits(64) baseregister;
    bits(64) inputaddr; // Input Address is 'vaddress' for stage 1, 'ipaddress' for stage 2

    descaddr.memattrs.type = MemType_Normal;

    // Derived parameters for the page table walk:
    // grainsize = Log2(Size of Table) - Size of Table is 4KB, 16KB or 64KB in AArch64
    // stride = Log2(Address per Level) - Bits of address consumed at each level
    // firstblocklevel = First level where a block entry is allowed
    // ps = Physical Address size as encoded in TCR_EL1.IPS or TCR_ELx/VTCR_EL2.PS
    // inputsize = Log2(Size of Input Address) - Input Address size in bits
    // level = Level to start walk from
    // This means that the number of levels after start level = 3-level

    if !secondstage then
        // First stage translation
        inputaddr = ZeroExtend(vaddress);
        top = AddrTop(inputaddr);
        else
            if inputaddr < top > == '0' then
                inputsize = 64 - UInt(TCR_EL1.T0SZ);
                if inputsize > 48 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_FORCE, Constraint_FAULT};
                    if c == Constraint_FORCE then inputsize = 48;
                if inputsize < 25 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_FORCE, Constraint_FAULT};
                    if c == Constraint_FORCE then inputsize = 25;
                largegrain = TCR_EL1.TG0 == '01';
                midgrain = TCR_EL1.TG0 == '10';
                basefound = inputsize >= 25 & & inputsize <= 48 & & IsZero(inputaddr < top: inputsize >);
                disabled = TCR_EL1.EPD0 == '1';
                baseregister = TTBR0_EL1;
                descaddr.memattrs = WalkAttrDecode(
                    TCR_EL1.SH0, TCR_EL1.ORGN0, TCR_EL1.IRGN0);

            ps = TCR_EL1.IPS;
            reversedescriptors = SCTLR_EL1.EE == '1';
            lookupsecure = IsSecure();
            singlepriv = FALSE;

        grainsize = 14; // Log2(16KB page size)
        firstblocklevel = 2; // Largest block is 32MB(2 ^ 25 bytes)
        stride = grainsize - 3; // Log2(page size / 8 bytes)
        // The starting level is the number of strides needed to consume the input address
        level = 4 - RoundUp(Real(inputsize - grainsize) / Real(stride));

    if !basefound | | disabled then
        level = 0; // AArch32 reports this as a level 1 fault
        result.addrdesc.fault = AArch64.TranslationFault(ipaddress, level, acctype, iswrite,
                                                         secondstage, s2fs1walk);
        return result;

    case ps of
        when '000'  outputsize = 32;
        when '001'  outputsize = 36;
        when '010'  outputsize = 40;
        when '011'  outputsize = 42;
        when '100'  outputsize = 44;
        when '101'  outputsize = 48;
        otherwise   outputsize = 48;

    if outputsize > PAMax() then outputsize = PAMax();

    if outputsize != 48 & & !IsZero(baseregister < 47: outputsize > ) then
        level = 0;
        result.addrdesc.fault = AArch64.AddressSizeFault(ipaddress, level, acctype, iswrite,
                                                         secondstage, s2fs1walk);
        return result;

    // Bottom bound of the Base address is:
    // Log2(8 bytes per entry)+Log2(Number of entries in starting level table)
    // Number of entries in starting level table =
    // (Size of Input Address)/(Address pre level) ^ (Num level remaining)*(Size of Table))
    baselowerbound=3 + inputsize - ((3-level)*stride + grainsize); // Log2(Num of entries*8)
    baseaddress = baseregister < 47: baselowerbound > : Zeros(baselowerbound);

    ns_table=if lookupsecure then '0' else '1';
    ap_table='00';
    xn_table='0';
    pxn_table='0';

    addrselecttop=inputsize - 1;

    repeat
        addrselectbottom=(3-level)*stride + grainsize;

        bits(48) index = ZeroExtend(inputaddr < addrselecttop: addrselectbottom > : '000');
        descaddr.paddress.physicaladdress=baseaddress OR index;
        descaddr.paddress.NS=ns_table;

        // If there are two stages of translation, then the first stage table walk addresses
        // are themselves subject to translation
        if !HaveEL(EL2) | | secondstage | | IsSecure() | | PSTATE.EL == EL2 then
            descaddr2=descaddr;
        else
            descaddr2=AArch64.SecondStageWalk(
                descaddr, vaddress, acctype, iswrite, 8);
            // Check for a fault on the stage 2 walk
            if IsFault(descaddr2) then
                result.addrdesc.fault=descaddr2.fault;
                return result;

        // Update virtual address for abort functions
        descaddr2.vaddress=ZeroExtend(vaddress);

        desc=_Mem[descaddr2, 8, AccType_PTW];
        if reversedescriptors then desc=BigEndianReverse(desc);

        if desc < 0 > == '0' | | (desc < 1: 0 > == '01' & & level == 3) then
            // Fault(00), Reserved(10), or Block(01) at level 3
            result.addrdesc.fault=AArch64.TranslationFault(ipaddress, level, acctype,
                                                             iswrite, secondstage, s2fs1walk);
            return result;

        // Valid Block, Page, or Table entry
        if desc < 1: 0 > == '01' | | level == 3 then // Block(01) or Page(11)
            blocktranslate=TRUE;
        else // Table(11)
            if outputsize != 48 & & !IsZero(desc < 47: outputsize > ) then
                result.addrdesc.fault=AArch64.AddressSizeFault(ipaddress, level, acctype,
                                                                 iswrite, secondstage, s2fs1walk);
                return result;

            baseaddress = desc < 47: grainsize > : Zeros(grainsize);

            if !secondstage then
                // Unpack the upper and lower table attributes
                ns_table = ns_table OR desc < 63 > ;
                ap_table < 1 > = ap_table < 1 > OR desc < 62 > ;      // read-only
                xn_table = xn_table OR desc < 60 > ;
                // pxn_table and ap_table[0] apply only in EL1 & 0 translation regimes
                if !singlepriv then
                    ap_table < 0 > = ap_table < 0 > OR desc < 61 > ;  // privileged
                    pxn_table = pxn_table OR desc < 59 > ;

            level=level + 1;
            addrselecttop=addrselectbottom - 1; blocktranslate=FALSE;
    until blocktranslate;

    // Check block size is supported at this level
    if level < firstblocklevel then
        result.addrdesc.fault=AArch64.TranslationFault(ipaddress, level, acctype,
                                                         iswrite, secondstage, s2fs1walk);
        return result;

    // Check for misprogramming of the contiguous bit
    if largegrain then
        contiguousbitcheck = level == 2 && inputsize < 34;
    elsif midgrain then
        contiguousbitcheck = level == 2 && inputsize < 30;
    else
        contiguousbitcheck = level == 1 && inputsize < 34;

    if contiguousbitcheck && desc<52> == '1' then
        if boolean IMPLEMENTATION_DEFINED "Translation fault on misprogrammed contiguous bit" then
            result.addrdesc.fault = AArch64.TranslationFault(ipaddress, level, acctype,
                                                             iswrite, secondstage, s2fs1walk);
            return result;

    // Check the output address is inside the supported range
    if outputsize != 48 && !IsZero(desc<47:outputsize>) then
        result.addrdesc.fault = AArch64.AddressSizeFault(ipaddress, level, acctype,
                                                         iswrite, secondstage, s2fs1walk);
        return result;

    // Check the access flag
    if desc<10> == '0' then
        result.addrdesc.fault = AArch64.AccessFlagFault(ipaddress, level, acctype,
                                                        iswrite, secondstage, s2fs1walk);
        return result;

    // Unpack the descriptor into address and upper and lower block attributes
    outputaddress = desc<47:addrselectbottom>:inputaddr<addrselectbottom-1:0>;
    xn = desc<54>;
    pxn = desc<53>;
    contiguousbit = desc<52>;
    nG = desc<11>;
    sh = desc<9:8>;
    ap = desc<7:6>:'1';
    memattr = desc<5:2>;                // AttrIndx and NS bit in stage 1

    result.domain = bits(4) UNKNOWN;    // Domains not used
    result.level = level;
    result.blocksize = 2^((3-level)*stride + grainsize);

    // Stage 1 translation regimes also inherit attributes from the tables
    if !secondstage then
        result.perms.xn = xn OR xn_table;
        result.perms.ap<2> = ap<2> OR ap_table<1>; // Force read-only

        // PXN, nG and AP[1] apply only in EL1&0 stage 1 translation regimes
        if !singlepriv then
            result.perms.ap<1> = ap<1> AND NOT(ap_table<0>); // Force privileged only
            result.perms.pxn = pxn OR pxn_table;
            // Pages from Non-secure tables are marked non-global in Secure EL1&0
            if IsSecure() then
                result.nG = nG OR ns_table;
            else
                result.nG = nG;
        else
            result.perms.ap<1> = '1';
            result.perms.pxn   = '0';
            result.nG          = '0';
        result.perms.ap<0> = '1';
        result.addrdesc.memattrs = AArch64.S1AttrDecode(sh, memattr<2:0>, acctype); result.addrdesc.paddress.NS = memattr<3> OR ns_table;
    else
        result.perms.ap<2:1> = ap<2:1>;
        result.perms.ap<0>   = '1';
        result.perms.xn      = xn;
        result.perms.pxn     = '0';
        result.nG            = '0';
        result.addrdesc.memattrs = S2AttrDecode(sh, memattr, acctype);
        result.addrdesc.paddress.NS = '1';

    result.addrdesc.paddress.physicaladdress = outputaddress;
    result.addrdesc.fault = AArch64.NoFault();
    result.contiguous = contiguousbit == '1';

    return result;
